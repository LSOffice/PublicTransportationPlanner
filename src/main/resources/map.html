<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <style>
    html,
    body,
    #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #map {
      background: #ddd;
    }

    /* keep things simple and avoid heavy transforms */
    .leaflet-container {
      -webkit-transform: none !important;
      transform: none !important;
    }

    /* floating controls */
    #controls {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 13px;
    }

    #controls input[type="range"] {
      width: 160px;
    }

    #controls input[type="text"] {
      width: 70px;
    }

    #drawBtn {
      margin-left: 8px;
      padding: 4px 8px;
    }

    #areaLabel {
      display: inline-block;
      margin-left: 8px;
      font-weight: bold;
    }

    #message {
      display: inline-block;
      margin-left: 12px;
      color: red;
      font-weight: bold;
    }

    #centroid {
      display: inline-block;
      margin-left: 8px;
    }

    #neighbourhoodInfo {
      display: block;
      margin-top: 6px;
      font-size: 13px;
    }

    #neighbourhoodInfo pre {
      white-space: pre-wrap;
      max-width: 480px;
    }

    /* density label for circle tooltips */
    .density-label {
      background: rgba(255, 255, 255, 0.85) !important;
      color: #000 !important;
      padding: 2px 6px !important;
      border-radius: 4px !important;
      font-weight: 700 !important;
      font-size: 12px !important;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.25) !important;
      pointer-events: none !important;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div id="controls">
    Zoom:
    <input id="zoomRange" type="range" min="1" max="19" step="0.01" value="10" />
    <input id="zoomValue" type="text" value="10" />
    <button id="drawBtn">Draw</button>
    <button id="suggestBtn" disabled style="margin-left: 8px">
      Suggestions
    </button>
    <button id="hideSuggestBtn" disabled style="margin-left: 4px">
      Hide Suggestions
    </button>
    <button id="tubeMapBtn" disabled style="margin-left: 8px">
      Tube Map
    </button>
    <span id="areaLabel">Area: <span id="areaDisplay">—</span> km²</span>
    <span id="message"></span>
    <div id="centroidRow">
      Center: <span id="centroid">—</span>
      <span id="density" style="margin-left: 12px; font-weight: bold"></span>
    </div>
    <div id="neighbourhoodInfo">
      Neighbourhood:
      <pre id="neighProps">—</pre>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    // Minimal full-screen Leaflet map
    const map = L.map("map", {
      center: [51.5074, -0.1278],
      zoom: 10,
      dragging: true,
      scrollWheelZoom: true,
      touchZoom: true,
      zoomAnimation: false,
      preferCanvas: false,
    });

    const tileLayer = L.tileLayer(
      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      {
        maxZoom: 19,
        attribution: "© OpenStreetMap",
      },
    ).addTo(map);

    // Controls
    const zoomRange = document.getElementById("zoomRange");
    const zoomValue = document.getElementById("zoomValue");
    const drawBtn = document.getElementById("drawBtn");
    const areaDisplay = document.getElementById("areaDisplay");
    const messageEl = document.getElementById("message");
    const centroidEl = document.getElementById("centroid");
    const densityEl = document.getElementById("density");
    const neighPropsEl = document.getElementById("neighProps");

    // Grid overlay: layer and cached data
    const gridLayer = L.layerGroup().addTo(map);
    // Suggestions overlay: stations and proposed lines
    const suggestionsLayer = L.layerGroup().addTo(map);
    let gridData = null;

    async function loadGridCsv() {
      if (gridData !== null) return gridData;
      try {
        const resp = await fetch("/gbr_pd_2020_1km_ASCII_XYZ.csv");
        if (!resp.ok) throw new Error("Failed to load CSV");
        const text = await resp.text();
        const lines = text.split(/\r?\n/);
        const out = [];
        for (let i = 1; i < lines.length; i++) {
          const l = lines[i].trim();
          if (!l) continue;
          const parts = l.split(",");
          if (parts.length < 3) continue;
          const x = parseFloat(parts[0]);
          const y = parseFloat(parts[1]);
          const z = parseFloat(parts[2]);
          if (isNaN(x) || isNaN(y) || isNaN(z)) continue;
          out.push({ lon: x, lat: y, value: z });
        }
        gridData = out;
        return gridData;
      } catch (err) {
        console.error("loadGridCsv error", err);
        gridData = [];
        return gridData;
      }
    }

    function styleForValue(v) {
      // simple color ramp
      if (v <= 1)
        return {
          color: "#1a9850",
          fillColor: "#a6d96a",
          fillOpacity: 0.6,
          weight: 1,
        };
      if (v <= 5)
        return {
          color: "#66bd63",
          fillColor: "#66bd63",
          fillOpacity: 0.6,
          weight: 1,
        };
      if (v <= 20)
        return {
          color: "#fdae61",
          fillColor: "#fdae61",
          fillOpacity: 0.6,
          weight: 1,
        };
      return {
        color: "#d73027",
        fillColor: "#d73027",
        fillOpacity: 0.6,
        weight: 1,
      };
    }

    function radiusForValue(v) {
      // map value to circle radius (meters) - reduced scale and capped
      const base = 10; // smaller minimum radius
      const r = base + v * 6; // much smaller multiplier than before
      return Math.max(5, Math.min(500, r));
    }

    function radiusForValueRelative(v, minV, maxV) {
      const minR = 6; // meters
      const maxR = 200; // meters (relative cap)
      if (!isFinite(v)) return minR;
      if (!isFinite(minV) || !isFinite(maxV) || maxV === minV) {
        // fallback to small absolute radius
        return Math.max(5, Math.min(200, 6 + v * 6));
      }
      const t = (v - minV) / (maxV - minV);
      return minR + t * (maxR - minR);
    }

    // Initialize range and text
    zoomRange.value = map.getZoom();
    zoomValue.value = map.getZoom();

    // Update map when slider changes (allow fractional zoom)
    zoomRange.addEventListener("input", function () {
      const z = parseFloat(this.value);
      map.setZoom(z);
      zoomValue.value = z.toFixed(2);
    });

    // Update map when text input changes
    zoomValue.addEventListener("change", function () {
      const v = parseFloat(this.value);
      if (!isNaN(v)) {
        const clamped = Math.max(1, Math.min(19, v));
        map.setZoom(clamped);
        zoomRange.value = clamped;
        this.value = clamped.toFixed(2);
      } else {
        this.value = map.getZoom().toFixed(2);
      }
    });

    // Sync slider when user uses map zoom controls (mouse wheel or +/-)
    map.on("zoom", function () {
      const z = map.getZoom();
      zoomRange.value = z;
      zoomValue.value = z.toFixed(2);
    });

    // Drawing via Leaflet.draw
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
      draw: {
        polygon: true,
        polyline: false,
        rectangle: true,
        circle: false,
        marker: false,
        circlemarker: false,
      },
      edit: {
        featureGroup: drawnItems,
        edit: true,
        remove: true,
      },
    });

    let drawMode = false;
    let activeDrawer = null;

    function enableDraw() {
      messageEl.textContent = "";
      drawMode = true;
      drawBtn.textContent = "Cancel Draw";
      try {
        map.dragging.disable();
      } catch (e) { }
      try {
        map.scrollWheelZoom.disable();
      } catch (e) { }
      try {
        map.touchZoom.disable();
      } catch (e) { }
      activeDrawer = new L.Draw.Polygon(
        map,
        drawControl.options.draw.polygon ? {} : {},
      );
      activeDrawer.enable();
    }

    function disableDraw() {
      drawMode = false;
      drawBtn.textContent = "Draw";
      try {
        map.dragging.enable();
      } catch (e) { }
      try {
        map.scrollWheelZoom.enable();
      } catch (e) { }
      try {
        map.touchZoom.enable();
      } catch (e) { }
      if (activeDrawer) {
        try {
          activeDrawer.disable();
        } catch (e) { }
        activeDrawer = null;
      }
    }

    drawBtn.addEventListener("click", function () {
      if (!drawMode) enableDraw();
      else disableDraw();
    });

    // Wire suggestion buttons
    try {
      suggestBtn.addEventListener("click", function () {
        try {
          showSuggestions();
        } catch (e) {
          console.error("showSuggestions click failed", e);
          messageEl.textContent = "Suggestions error";
        }
      });
      hideSuggestBtn.addEventListener("click", function () {
        try {
          clearSuggestions();
        } catch (e) {
          console.error("clearSuggestions click failed", e);
        }
      });
      document
        .getElementById("tubeMapBtn")
        .addEventListener("click", function () {
          try {
            generateTubeMap(window._lastLineData);
          } catch (e) {
            console.error("tubeMapBtn click failed", e);
            messageEl.textContent = "Tube map generation error";
          }
        });
    } catch (e) {
      console.warn("Failed to bind suggestion buttons", e);
    }

    function clearExisting() {
      drawnItems.clearLayers();
      try {
        gridLayer.clearLayers();
      } catch (e) { }
      try {
        suggestionsLayer.clearLayers();
      } catch (e) { }
      areaDisplay.textContent = "—";
      messageEl.textContent = "";
      centroidEl.textContent = "—";
      densityEl.textContent = "";
      neighPropsEl.textContent = "—";
    }

    const AREA_CAP_KM2 = 84000.0;

    function computeCentroidCoords(geojson) {
      try {
        const c = turf.centroid(geojson);
        if (c && c.geometry && c.geometry.coordinates) {
          const lon = c.geometry.coordinates[0];
          const lat = c.geometry.coordinates[1];
          return [lat, lon];
        }
      } catch (err) {
        console.error("centroid error", err);
      }
      return null;
    }

    // Neighbourhood repository lookup disabled to avoid external camaraproject requests.
    async function findNeighbourhoodData(lat, lon) {
      messageEl.textContent = "Neighbourhood repository lookup disabled";
      neighPropsEl.textContent = "disabled";
      return null;
    }

    map.on(L.Draw.Event.CREATED, async function (e) {
      const layer = e.layer;
      try {
        const geojson = layer.toGeoJSON();
        const areaSqMeters = turf.area(geojson);
        const areaKm2 = areaSqMeters / 1e6;
        if (areaKm2 > AREA_CAP_KM2) {
          messageEl.textContent = `Invalid: selected area ${areaKm2.toFixed(2)} km² exceeds limit of ${AREA_CAP_KM2.toLocaleString()} km²`;
          try {
            layer.remove();
          } catch (e) { }
          return;
        }

        clearExisting();
        drawnItems.addLayer(layer);
        areaDisplay.textContent = areaKm2.toFixed(4);

        const centroid = computeCentroidCoords(geojson);
        if (centroid) {
          const lat = centroid[0];
          const lon = centroid[1];
          centroidEl.textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
          // First: check our CSV density grid via local server endpoint
          messageEl.textContent = "Checking density grid...";
          try {
            const resp = await fetch(
              `/density?lon=${encodeURIComponent(lon)}&lat=${encodeURIComponent(lat)}&max_m=1000`,
            );
            if (resp.ok) {
              const json = await resp.json();
              densityEl.textContent = `Density: ${Number(json.value).toLocaleString()} (nearest ${Number(json.distance_m).toFixed(1)} m)`;
              messageEl.textContent = "";
              try {
                L.popup({ maxWidth: 300 })
                  .setLatLng([json.lat, json.lon])
                  .setContent(
                    `<strong>Population density</strong><br/>${Number(json.value).toLocaleString()}<br/><small>distance ${Number(json.distance_m).toFixed(1)} m</small>`,
                  )
                  .openOn(map);
              } catch (e) {
                console.warn("popup failed", e);
              }
            } else if (resp.status === 404) {
              const txt = await resp.text();
              messageEl.textContent = txt || "No grid cell within 1000 m";
              densityEl.textContent = "Density: not found within 1 km";
            } else {
              const txt = await resp.text();
              messageEl.textContent = `Density lookup failed: ${txt}`;
            }
          } catch (err) {
            console.error("density lookup error", err);
            messageEl.textContent = "Density lookup error";
          }

          // Draw grid cells from CSV that intersect the drawn polygon
          messageEl.textContent =
            messageEl.textContent || "Finding intersecting grid cells...";
          try {
            const csv = await loadGridCsv();
            try {
              gridLayer.clearLayers();
            } catch (e) { }
            let count = 0;
            const poly = geojson; // drawn polygon GeoJSON
            const matches = [];
            for (const g of csv) {
              try {
                const pt = turf.point([g.lon, g.lat]);
                if (turf.booleanPointInPolygon(pt, poly)) {
                  matches.push(g);
                }
              } catch (e) {
                continue;
              }
            }
            if (matches.length > 0) {
              const vals = matches
                .map((m) => m.value)
                .filter((v) => isFinite(v));
              const minV = vals.length ? Math.min(...vals) : NaN;
              const maxV = vals.length ? Math.max(...vals) : NaN;
              for (const g of matches) {
                try {
                  const st = styleForValue(g.value);
                  const radius = radiusForValueRelative(g.value, minV, maxV);
                  const c = L.circle([g.lat, g.lon], {
                    radius: radius,
                    color: st.color,
                    fillColor: st.fillColor,
                    fillOpacity: st.fillOpacity,
                    weight: 1,
                  }).addTo(gridLayer);
                  c.bindPopup(
                    `Value: ${Number(g.value)}\n${g.lon.toFixed(6)}, ${g.lat.toFixed(6)}\nRadius: ${Math.round(radius)} m`,
                  );
                  try {
                    c.bindTooltip(`${Number(g.value)}`, {
                      permanent: true,
                      direction: "center",
                      className: "density-label",
                      interactive: false,
                    });
                  } catch (e) { }
                  count += 1;
                } catch (e) {
                  continue;
                }
              }
            }
            messageEl.textContent =
              count > 0
                ? `Found ${count} grid cells intersecting selection`
                : "No grid cells intersect selection";

            // Store matches and enable the Suggestions button; user triggers suggestions manually
            try {
              window._lastMatches = matches.slice();
              if (matches.length > 0) {
                suggestBtn.disabled = false;
                hideSuggestBtn.disabled = true;
                messageEl.textContent = `Found ${matches.length} grid points inside selection — click Suggestions to request routes`;
              } else {
                suggestBtn.disabled = true;
                hideSuggestBtn.disabled = true;
              }
            } catch (e) {
              console.warn("store matches failed", e);
            }
          } catch (err) {
            console.error("grid overlay error", err);
            messageEl.textContent = "Grid overlay error";
          }
        }

        disableDraw();
        drawBtn.disabled = true;
        messageEl.textContent = "";
      } catch (err) {
        console.error("Area calculation failed", err);
        messageEl.textContent = "Area calculation failed";
      }
    });

    // Suggestions: show/hide handlers
    function clearSuggestions() {
      try {
        suggestionsLayer.clearLayers();
      } catch (e) { }
      // show population density grid again
      try {
        if (!map.hasLayer(gridLayer)) map.addLayer(gridLayer);
      } catch (e) { }
      hideSuggestBtn.disabled = true;
      suggestBtn.disabled =
        window._lastMatches && window._lastMatches.length ? false : true;
      document.getElementById("tubeMapBtn").disabled = true;
      messageEl.textContent = "";
    }

    function showSuggestions() {
      try {
        const matches = (window._lastMatches || []).slice();
        if (!matches || matches.length === 0) {
          messageEl.textContent = "No matches available for suggestions";
          return;
        }

        suggestionsLayer.clearLayers();
        // hide the population density grid layer while showing suggestions
        try {
          if (map.hasLayer(gridLayer)) map.removeLayer(gridLayer);
        } catch (e) { }

        // POST matches to /suggestions endpoint
        const csvBody = matches
          .map((m) => `${m.lon},${m.lat},${m.value}`)
          .join("\n");
        fetch("/suggestions", {
          method: "POST",
          headers: { "Content-Type": "text/plain" },
          body: csvBody,
        })
          .then((resp) => {
            if (!resp.ok)
              throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
            return resp.json();
          })
          .then((data) => {
            const lineColors = [
              "#2b83ba",
              "#fdae61",
              "#66bd63",
              "#7b3294",
              "#d73027",
              "#1f78b4",
              "#e31a1c",
            ];

            // Line type colors (overrides default)
            const lineTypeColors = {
              RADIAL_TRUNK: "#d62728", // red
              CORE_DISTRIBUTOR: "#ff7f0e", // orange
              ORBITAL: "#2ca02c", // green
              NOT_METRO: "#cccccc", // gray (unlikely)
            };

            const created = {};
            const allLineBounds = [];
            const transfers = new Set();

            // First pass: collect all stations and detect intersections
            const allStations = new Map();
            data.lines.forEach((line, li) => {
              line.stations.forEach((st) => {
                const key = `${st.lon},${st.lat}`;
                if (!allStations.has(key))
                  allStations.set(key, { ...st, lines: [] });
                allStations.get(key).lines.push(li);
              });
            });
            allStations.forEach((st) => {
              if (st.lines.length > 1) transfers.add(`${st.lon},${st.lat}`);
            });

            // Render lines and stations
            data.lines.forEach((line, li) => {
              const lineType = line.type || "RADIAL_TRUNK";
              const isLoop = line.isLoop || false;
              const color =
                lineTypeColors[lineType] ||
                lineColors[li % lineColors.length];
              const latlngs = line.stations.map((st) => [st.lat, st.lon]);

              // Use dashed style for loops
              const polylineStyle = isLoop
                ? {
                  color: color,
                  weight: 3,
                  opacity: 0.95,
                  dashArray: "5, 5",
                }
                : { color: color, weight: 3, opacity: 0.95 };

              const poly = L.polyline(latlngs, polylineStyle).addTo(
                suggestionsLayer,
              );

              // Add label with line type and ID on the polyline
              const midIdx = Math.floor(latlngs.length / 2);
              if (midIdx < latlngs.length) {
                const midPoint = latlngs[midIdx];
                const loopMarker = isLoop ? " ⭕" : "";
                L.marker(midPoint, {
                  icon: L.divIcon({
                    className: "line-label",
                    html: `<div style="background:${color};color:#fff;padding:2px 6px;border-radius:3px;font-weight:bold;font-size:12px;">${line.id}${loopMarker}</div>`,
                  }),
                }).addTo(suggestionsLayer);
              }

              allLineBounds.push(poly.getBounds());

              line.stations.forEach((st, si) => {
                const key = `${st.lon},${st.lat}`;
                if (created[key]) return;
                const isTransfer = transfers.has(key);
                const radius = isTransfer
                  ? 10
                  : Math.max(6, Math.min(18, (st.value || 0) / 100));
                const m = L.circleMarker([st.lat, st.lon], {
                  radius: radius,
                  color: isTransfer ? "#c62828" : color,
                  fillColor: isTransfer ? "#c62828" : color,
                  fillOpacity: 0.95,
                  weight: 1,
                }).addTo(suggestionsLayer);
                const loopInfo = isLoop ? " [loop line]" : "";
                m.bindPopup(
                  `<strong>Station ${st.id}</strong><br/>Type: ${lineType}${loopInfo}<br/>Value: ${Number(st.value || 0).toLocaleString()}<br/>${st.lon.toFixed(6)}, ${st.lat.toFixed(6)}`,
                );
                m.bindTooltip(`${st.id}`, {
                  permanent: true,
                  direction: "center",
                });
                created[key] = m;
              });
            });

            // Fit map
            if (allLineBounds.length > 0) {
              try {
                const combined = allLineBounds.reduce(
                  (acc, b) => acc.extend(b),
                  allLineBounds[0],
                );
                map.fitBounds(combined, { padding: [20, 20] });
              } catch (e) { }
            }

            suggestBtn.disabled = true;
            hideSuggestBtn.disabled = false;
            const lineSummary = data.lines
              .map((l) => {
                const loopMarker = l.isLoop ? " ⭕" : "";
                return `${l.id} (${l.type})${loopMarker}`;
              })
              .join(", ");
            messageEl.textContent = `Showing ${data.lines.length} metro lines: ${lineSummary}`;

            // Store line data for tube map generation
            window._lastLineData = data;
            document.getElementById("tubeMapBtn").disabled = false;
          })
          .catch((err) => {
            console.error("Suggestions fetch error", err);
            messageEl.textContent = "Failed to fetch suggestions";
          });
      } catch (err) {
        console.error("showSuggestions error", err);
        messageEl.textContent = "Suggestions error";
      }
    }

    // Ensure the map recalculates size when the page finishes loading
    window.addEventListener("load", function () {
      setTimeout(function () {
        try {
          map.invalidateSize();
        } catch (e) { }
      }, 50);
    });

    // Generate London Underground-style schematic tube map
    function generateTubeMap(lineData) {
      if (!lineData || lineData.lines.length === 0) {
        messageEl.textContent = "No line data available for tube map";
        return;
      }

      const lines = lineData.lines;
      // Assign a distinct color to each line (HSL palette)
      const lineColors = {};
      function colorForIndex(i, total) {
        const hue = Math.round((i * 360) / Math.max(1, total));
        return `hsl(${hue},70%,45%)`;
      }
      lines.forEach((ln, idx) => {
        lineColors[ln.id] = colorForIndex(idx, lines.length);
      });

      // Calculate layout: collect all stations
      const allStations = new Map();
      const lineStationMaps = [];

      lines.forEach((line) => {
        const lineStations = [];
        line.stations.forEach((st) => {
          const key = `${st.lon.toFixed(4)},${st.lat.toFixed(4)}`;
          if (!allStations.has(key)) {
            allStations.set(key, {
              id: st.id,
              lon: st.lon,
              lat: st.lat,
              value: st.value,
              lines: [],
            });
          }
          allStations.get(key).lines.push(line.id);
          lineStations.push(key);
        });
        lineStationMaps.push({ line, stationKeys: lineStations });
      });

      // Compute bounds
      const lons = Array.from(allStations.values()).map((s) => s.lon);
      const lats = Array.from(allStations.values()).map((s) => s.lat);
      const minLon = Math.min(...lons);
      const maxLon = Math.max(...lons);
      const minLat = Math.min(...lats);
      const maxLat = Math.max(...lats);

      // Map geographic coords to schematic layout
      const margin = 60;
      const svgWidth = 1200;
      const svgHeight = 900;
      const plotWidth = svgWidth - 2 * margin;
      const plotHeight = svgHeight - 2 * margin;

      const lonRange = maxLon - minLon || 1;
      const latRange = maxLat - minLat || 1;

      const stationPositions = new Map();
      allStations.forEach((st, key) => {
        const x = margin + ((st.lon - minLon) / lonRange) * plotWidth;
        const y =
          margin + plotHeight - ((st.lat - minLat) / latRange) * plotHeight; // flip y
        stationPositions.set(key, { x, y, station: st });
      });

      // Generate SVG
      let svg = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Metro Network - Schematic Map</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    svg {
      background: white;
      border: 1px solid #ddd;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .line {
      stroke-width: 4;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .station {
      fill: white;
      stroke-width: 2;
    }
    .station-label {
      font-size: 11px;
      font-weight: bold;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }
    .title {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 15px;
    }
    .legend {
      margin-top: 15px;
      font-size: 12px;
    }
    .legend-item {
      display: inline-block;
      margin-right: 20px;
    }
    .legend-color {
      display: inline-block;
      width: 20px;
      height: 3px;
      margin-right: 6px;
      vertical-align: middle;
    }
  </style>
</head>
<body>
  <div class="title">Metro Network Schematic Map</div>
  <svg width="${svgWidth}" height="${svgHeight}">`;

      // Draw lines (each line gets a distinct color)
      lineStationMaps.forEach((lineMap, idx) => {
        const color = lineColors[lineMap.line.id] || "#999";
        const lineId = lineMap.line.id;
        const label = `${lineMap.line.id} (${lineMap.line.type})`;

        // Draw path connecting stations in order
        let pathD = "";
        for (let i = 0; i < lineMap.stationKeys.length; i++) {
          const key = lineMap.stationKeys[i];
          const pos = stationPositions.get(key);
          if (pos) {
            if (i === 0) {
              pathD += `M${pos.x},${pos.y}`;
            } else {
              pathD += `L${pos.x},${pos.y}`;
            }
          }
        }

        svg += `<path class="line" d="${pathD}" stroke="${color}" opacity="0.8" />`;
      });

      // Draw stations (order matters: draw on top)
      const stationList = Array.from(stationPositions.entries());
      stationList.forEach(([key, pos]) => {
        const isTransfer = pos.station.lines.length > 1;
        const radius = isTransfer ? 6 : 4;
        const strokeColor = isTransfer ? "#c62828" : "#333";
        svg += `<circle class="station" cx="${pos.x}" cy="${pos.y}" r="${radius}" stroke="${strokeColor}" />`;
      });

      // Draw station labels
      stationList.forEach(([key, pos]) => {
        const label = pos.station.id.replace("st_", "");
        svg += `<text class="station-label" x="${pos.x}" y="${pos.y - 14}" fill="#000">${label}</text>`;
      });

      // Add legend (per-line colors)
      svg += `<g>
        <text x="20" y="30" font-size="12" font-weight="bold">Legend:</text>`;
      let legendY = 50;
      lineStationMaps.forEach((lm, i) => {
        const color = lineColors[lm.line.id] || "#999";
        const labelTxt = `${lm.line.id} (${lm.line.type})`;
        svg += `<line x1="20" y1="${legendY}" x2="40" y2="${legendY}" stroke="${color}" stroke-width="3" />`;
        svg += `<text x="50" y="${legendY + 5}" font-size="11">${labelTxt}</text>`;
        legendY += 20;
      });
      svg += `</g>`;

      svg += `</svg>
  <div class="legend">
    <div class="legend-item"><span class="legend-color" style="background: #d62728;"></span><strong>Radial Trunk:</strong> Main arterial lines</div>
    <div class="legend-item"><span class="legend-color" style="background: #ff7f0e;"></span><strong>Core Distributor:</strong> Inner-city network</div>
    <div class="legend-item"><span class="legend-color" style="background: #2ca02c;"></span><strong>Orbital:</strong> Ring/circumferential</div>
  </div>
  <p style="margin-top: 20px; font-size: 12px; color: #666;">
    <strong>Note:</strong> This is a schematic diagram. Station positions are based on geographic coordinates but simplified for clarity.
    Larger circles indicate transfer stations (served by multiple lines).
  </p>
</body>
</html>`;

      // Open in new tab
      const blob = new Blob([svg], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      window.open(url, "_blank");
    }
  </script>
</body>

</html>